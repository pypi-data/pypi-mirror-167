{"version":3,"file":"chunks/app_actionCreators_projects_tsx-app_utils_useTeams_tsx.xxxxxxxxxxxxxxxxxxxx.js","mappings":"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","sources":["webpack:///./app/actionCreators/projects.tsx","webpack:///./app/actionCreators/teams.tsx","webpack:///./app/stores/projectsStatsStore.tsx","webpack:///./app/utils/isActiveSuperuser.tsx","webpack:///./app/utils/useTeams.tsx"],"sourcesContent":["import {Query} from 'history';\nimport chunk from 'lodash/chunk';\nimport debounce from 'lodash/debounce';\n\nimport {\n  addErrorMessage,\n  addLoadingMessage,\n  addSuccessMessage,\n} from 'sentry/actionCreators/indicator';\nimport ProjectActions from 'sentry/actions/projectActions';\nimport {Client} from 'sentry/api';\nimport {PlatformKey} from 'sentry/data/platformCategories';\nimport {t, tct} from 'sentry/locale';\nimport ProjectsStatsStore from 'sentry/stores/projectsStatsStore';\nimport {Project, Team} from 'sentry/types';\n\ntype UpdateParams = {\n  orgId: string;\n  projectId: string;\n  data?: {[key: string]: any};\n  query?: Query;\n};\n\nexport function update(api: Client, params: UpdateParams) {\n  ProjectActions.update(params.projectId, params.data);\n\n  const endpoint = `/projects/${params.orgId}/${params.projectId}/`;\n  return api\n    .requestPromise(endpoint, {\n      method: 'PUT',\n      data: params.data,\n    })\n    .then(\n      data => {\n        ProjectActions.updateSuccess(data);\n        return data;\n      },\n      err => {\n        ProjectActions.updateError(err, params.projectId);\n        throw err;\n      }\n    );\n}\n\ntype StatsParams = Pick<UpdateParams, 'orgId' | 'data' | 'query'>;\n\nexport function loadStats(api: Client, params: StatsParams) {\n  ProjectActions.loadStats(params.orgId, params.data);\n\n  const endpoint = `/organizations/${params.orgId}/stats/`;\n  api.request(endpoint, {\n    query: params.query,\n    success: data => {\n      ProjectActions.loadStatsSuccess(data);\n    },\n    error: data => {\n      ProjectActions.loadStatsError(data);\n    },\n  });\n}\n\n// This is going to queue up a list of project ids we need to fetch stats for\n// Will be cleared when debounced function fires\nconst _projectStatsToFetch: Set<string> = new Set();\n\n// Max projects to query at a time, otherwise if we fetch too many in the same request\n// it can timeout\nconst MAX_PROJECTS_TO_FETCH = 10;\n\nconst _queryForStats = (\n  api: Client,\n  projects: string[],\n  orgId: string,\n  additionalQuery: Query | undefined\n) => {\n  const idQueryParams = projects.map(project => `id:${project}`).join(' ');\n  const endpoint = `/organizations/${orgId}/projects/`;\n\n  const query: Query = {\n    statsPeriod: '24h',\n    query: idQueryParams,\n    ...additionalQuery,\n  };\n\n  return api.requestPromise(endpoint, {\n    query,\n  });\n};\n\nexport const _debouncedLoadStats = debounce(\n  (api: Client, projectSet: Set<string>, params: UpdateParams) => {\n    const storedProjects: {[key: string]: Project} = ProjectsStatsStore.getAll();\n    const existingProjectStats = Object.values(storedProjects).map(({id}) => id);\n    const projects = Array.from(projectSet).filter(\n      project => !existingProjectStats.includes(project)\n    );\n\n    if (!projects.length) {\n      _projectStatsToFetch.clear();\n      return;\n    }\n\n    // Split projects into more manageable chunks to query, otherwise we can\n    // potentially face server timeouts\n    const queries = chunk(projects, MAX_PROJECTS_TO_FETCH).map(chunkedProjects =>\n      _queryForStats(api, chunkedProjects, params.orgId, params.query)\n    );\n\n    Promise.all(queries)\n      .then(results => {\n        ProjectActions.loadStatsForProjectSuccess(\n          results.reduce((acc, result) => acc.concat(result), [])\n        );\n      })\n      .catch(() => {\n        addErrorMessage(t('Unable to fetch all project stats'));\n      });\n\n    // Reset projects list\n    _projectStatsToFetch.clear();\n  },\n  50\n);\n\nexport function loadStatsForProject(api: Client, project: string, params: UpdateParams) {\n  // Queue up a list of projects that we need stats for\n  // and call a debounced function to fetch stats for list of projects\n  _projectStatsToFetch.add(project);\n  _debouncedLoadStats(api, _projectStatsToFetch, params);\n}\n\nexport function setActiveProject(project: Project | null) {\n  ProjectActions.setActive(project);\n}\n\nexport function removeProject(api: Client, orgId: string, project: Project) {\n  const endpoint = `/projects/${orgId}/${project.slug}/`;\n\n  ProjectActions.removeProject(project);\n  return api\n    .requestPromise(endpoint, {\n      method: 'DELETE',\n    })\n    .then(\n      () => {\n        ProjectActions.removeProjectSuccess(project);\n        addSuccessMessage(\n          tct('[project] was successfully removed', {project: project.slug})\n        );\n      },\n      err => {\n        ProjectActions.removeProjectError(project);\n        addErrorMessage(tct('Error removing [project]', {project: project.slug}));\n        throw err;\n      }\n    );\n}\n\nexport function transferProject(\n  api: Client,\n  orgId: string,\n  project: Project,\n  email: string\n) {\n  const endpoint = `/projects/${orgId}/${project.slug}/transfer/`;\n\n  return api\n    .requestPromise(endpoint, {\n      method: 'POST',\n      data: {\n        email,\n      },\n    })\n    .then(\n      () => {\n        addSuccessMessage(\n          tct('A request was sent to move [project] to a different organization', {\n            project: project.slug,\n          })\n        );\n      },\n      err => {\n        let message = '';\n        // Handle errors with known failures\n        if (err.status >= 400 && err.status < 500 && err.responseJSON) {\n          message = err.responseJSON?.detail;\n        }\n\n        if (message) {\n          addErrorMessage(\n            tct('Error transferring [project]. [message]', {\n              project: project.slug,\n              message,\n            })\n          );\n        } else {\n          addErrorMessage(\n            tct('Error transferring [project]', {\n              project: project.slug,\n            })\n          );\n        }\n\n        throw err;\n      }\n    );\n}\n\n/**\n * Associate a team with a project\n */\n\n/**\n *  Adds a team to a project\n *\n * @param api API Client\n * @param orgSlug Organization Slug\n * @param projectSlug Project Slug\n * @param team Team data object\n */\nexport function addTeamToProject(\n  api: Client,\n  orgSlug: string,\n  projectSlug: string,\n  team: Team\n) {\n  const endpoint = `/projects/${orgSlug}/${projectSlug}/teams/${team.slug}/`;\n\n  addLoadingMessage();\n  ProjectActions.addTeam(team);\n\n  return api\n    .requestPromise(endpoint, {\n      method: 'POST',\n    })\n    .then(\n      project => {\n        addSuccessMessage(\n          tct('[team] has been added to the [project] project', {\n            team: `#${team.slug}`,\n            project: projectSlug,\n          })\n        );\n        ProjectActions.addTeamSuccess(team, projectSlug);\n        ProjectActions.updateSuccess(project);\n      },\n      err => {\n        addErrorMessage(\n          tct('Unable to add [team] to the [project] project', {\n            team: `#${team.slug}`,\n            project: projectSlug,\n          })\n        );\n        ProjectActions.addTeamError();\n        throw err;\n      }\n    );\n}\n\n/**\n * Removes a team from a project\n *\n * @param api API Client\n * @param orgSlug Organization Slug\n * @param projectSlug Project Slug\n * @param teamSlug Team Slug\n */\nexport function removeTeamFromProject(\n  api: Client,\n  orgSlug: string,\n  projectSlug: string,\n  teamSlug: string\n) {\n  const endpoint = `/projects/${orgSlug}/${projectSlug}/teams/${teamSlug}/`;\n\n  addLoadingMessage();\n  ProjectActions.removeTeam(teamSlug);\n\n  return api\n    .requestPromise(endpoint, {\n      method: 'DELETE',\n    })\n    .then(\n      project => {\n        addSuccessMessage(\n          tct('[team] has been removed from the [project] project', {\n            team: `#${teamSlug}`,\n            project: projectSlug,\n          })\n        );\n        ProjectActions.removeTeamSuccess(teamSlug, projectSlug);\n        ProjectActions.updateSuccess(project);\n      },\n      err => {\n        addErrorMessage(\n          tct('Unable to remove [team] from the [project] project', {\n            team: `#${teamSlug}`,\n            project: projectSlug,\n          })\n        );\n        ProjectActions.removeTeamError(err);\n        throw err;\n      }\n    );\n}\n\n/**\n * Change a project's slug\n *\n * @param prev Previous slug\n * @param next New slug\n */\nexport function changeProjectSlug(prev: string, next: string) {\n  ProjectActions.changeSlug(prev, next);\n}\n\n/**\n * Send a sample event\n *\n * @param api API Client\n * @param orgSlug Organization Slug\n * @param projectSlug Project Slug\n */\nexport function sendSampleEvent(api: Client, orgSlug: string, projectSlug: string) {\n  const endpoint = `/projects/${orgSlug}/${projectSlug}/create-sample/`;\n\n  return api.requestPromise(endpoint, {\n    method: 'POST',\n  });\n}\n\n/**\n * Creates a project\n *\n * @param api API Client\n * @param orgSlug Organization Slug\n * @param team The team slug to assign the project to\n * @param name Name of the project\n * @param platform The platform key of the project\n * @param options Additional options such as creating default alert rules\n */\nexport function createProject(\n  api: Client,\n  orgSlug: string,\n  team: string,\n  name: string,\n  platform: string,\n  options: {defaultRules?: boolean} = {}\n) {\n  return api.requestPromise(`/teams/${orgSlug}/${team}/projects/`, {\n    method: 'POST',\n    data: {name, platform, default_rules: options.defaultRules},\n  });\n}\n\n/**\n * Load platform documentation specific to the project. The DSN and various\n * other project specific secrets will be included in the documentation.\n *\n * @param api API Client\n * @param orgSlug Organization Slug\n * @param projectSlug Project Slug\n * @param platform Project platform.\n */\nexport function loadDocs(\n  api: Client,\n  orgSlug: string,\n  projectSlug: string,\n  platform: PlatformKey\n) {\n  return api.requestPromise(`/projects/${orgSlug}/${projectSlug}/docs/${platform}/`);\n}\n\n/**\n * Load the counts of my projects and all projects for the current user\n *\n * @param api API Client\n * @param orgSlug Organization Slug\n */\nexport function fetchProjectsCount(api: Client, orgSlug: string) {\n  return api.requestPromise(`/organizations/${orgSlug}/projects-count/`);\n}\n\n/**\n * Check if there are any releases in the last 90 days.\n * Used for checking if project is using releases.\n *\n * @param api API Client\n * @param orgSlug Organization Slug\n * @param projectId Project Id\n */\nexport async function fetchAnyReleaseExistence(\n  api: Client,\n  orgSlug: string,\n  projectId: number | string\n) {\n  const data = await api.requestPromise(`/organizations/${orgSlug}/releases/stats/`, {\n    method: 'GET',\n    query: {\n      statsPeriod: '90d',\n      project: projectId,\n      per_page: 1,\n    },\n  });\n\n  return data.length > 0;\n}\n","import {addErrorMessage, addSuccessMessage} from 'sentry/actionCreators/indicator';\nimport TeamActions from 'sentry/actions/teamActions';\nimport {Client} from 'sentry/api';\nimport {tct} from 'sentry/locale';\nimport {Team} from 'sentry/types';\nimport {callIfFunction} from 'sentry/utils/callIfFunction';\nimport {uniqueId} from 'sentry/utils/guid';\n\ntype CallbackOptions = {\n  error?: Function;\n  success?: Function;\n};\n\nconst doCallback = (\n  params: CallbackOptions = {},\n  name: keyof CallbackOptions,\n  ...args: any[]\n) => {\n  callIfFunction(params[name], ...args);\n};\n\n/**\n * Note these are both slugs\n */\ntype OrgSlug = {orgId: string};\ntype OrgAndTeamSlug = OrgSlug & {teamId: string};\n\n/**\n * This is the actual internal id, not username or email\n */\ntype MemberId = {memberId: string};\n\n// Fetch teams for org\nexport function fetchTeams(api: Client, params: OrgSlug, options: CallbackOptions) {\n  TeamActions.fetchAll(params.orgId);\n  return api.request(`/teams/${params.orgId}/`, {\n    success: data => {\n      TeamActions.fetchAllSuccess(params.orgId, data);\n      doCallback(options, 'success', data);\n    },\n    error: error => {\n      TeamActions.fetchAllError(params.orgId, error);\n      doCallback(options, 'error', error);\n    },\n  });\n}\n\n// Fetch user teams for current org and place them in the team store\nexport async function fetchUserTeams(api: Client, params: OrgSlug) {\n  const teams = await api.requestPromise(`/organizations/${params.orgId}/user-teams/`);\n  TeamActions.loadUserTeams(teams);\n}\n\nexport function fetchTeamDetails(\n  api: Client,\n  params: OrgAndTeamSlug,\n  options?: CallbackOptions\n) {\n  TeamActions.fetchDetails(params.teamId);\n  return api.request(`/teams/${params.orgId}/${params.teamId}/`, {\n    success: data => {\n      TeamActions.fetchDetailsSuccess(params.teamId, data);\n      doCallback(options, 'success', data);\n    },\n    error: error => {\n      TeamActions.fetchDetailsError(params.teamId, error);\n      doCallback(options, 'error', error);\n    },\n  });\n}\n\nexport function updateTeamSuccess(teamId: OrgAndTeamSlug['teamId'], data: Team) {\n  TeamActions.updateSuccess(teamId, data);\n}\n\nexport function joinTeam(\n  api: Client,\n  params: OrgAndTeamSlug & Partial<MemberId>,\n  options: CallbackOptions\n) {\n  const endpoint = `/organizations/${params.orgId}/members/${\n    params.memberId ?? 'me'\n  }/teams/${params.teamId}/`;\n  const id = uniqueId();\n\n  TeamActions.update(id, params.teamId);\n\n  return api.request(endpoint, {\n    method: 'POST',\n    success: data => {\n      TeamActions.updateSuccess(params.teamId, data);\n      doCallback(options, 'success', data);\n    },\n    error: error => {\n      TeamActions.updateError(id, params.teamId, error);\n      doCallback(options, 'error', error);\n    },\n  });\n}\n\nexport function leaveTeam(\n  api: Client,\n  params: OrgAndTeamSlug & Partial<MemberId>,\n  options: CallbackOptions\n) {\n  const endpoint = `/organizations/${params.orgId}/members/${\n    params.memberId || 'me'\n  }/teams/${params.teamId}/`;\n  const id = uniqueId();\n\n  TeamActions.update(id, params.teamId);\n\n  return api.request(endpoint, {\n    method: 'DELETE',\n    success: data => {\n      TeamActions.updateSuccess(params.teamId, data);\n      doCallback(options, 'success', data);\n    },\n    error: error => {\n      TeamActions.updateError(id, params.teamId, error);\n      doCallback(options, 'error', error);\n    },\n  });\n}\n\nexport function createTeam(api: Client, team: Pick<Team, 'slug'>, params: OrgSlug) {\n  TeamActions.createTeam(team);\n\n  return api\n    .requestPromise(`/organizations/${params.orgId}/teams/`, {\n      method: 'POST',\n      data: team,\n    })\n    .then(\n      data => {\n        TeamActions.createTeamSuccess(data);\n        addSuccessMessage(\n          tct('[team] has been added to the [organization] organization', {\n            team: `#${data.slug}`,\n            organization: params.orgId,\n          })\n        );\n        return data;\n      },\n      err => {\n        TeamActions.createTeamError(team.slug, err);\n        addErrorMessage(\n          tct('Unable to create [team] in the [organization] organization', {\n            team: `#${team.slug}`,\n            organization: params.orgId,\n          })\n        );\n        throw err;\n      }\n    );\n}\n\nexport function removeTeam(api: Client, params: OrgAndTeamSlug) {\n  TeamActions.removeTeam(params.teamId);\n\n  return api\n    .requestPromise(`/teams/${params.orgId}/${params.teamId}/`, {\n      method: 'DELETE',\n    })\n    .then(\n      data => {\n        TeamActions.removeTeamSuccess(params.teamId, data);\n        addSuccessMessage(\n          tct('[team] has been removed from the [organization] organization', {\n            team: `#${params.teamId}`,\n            organization: params.orgId,\n          })\n        );\n        return data;\n      },\n      err => {\n        TeamActions.removeTeamError(params.teamId, err);\n        addErrorMessage(\n          tct('Unable to remove [team] from the [organization] organization', {\n            team: `#${params.teamId}`,\n            organization: params.orgId,\n          })\n        );\n        throw err;\n      }\n    );\n}\n","import {createStore, StoreDefinition} from 'reflux';\n\nimport ProjectActions from 'sentry/actions/projectActions';\nimport {Project} from 'sentry/types';\nimport {makeSafeRefluxStore} from 'sentry/utils/makeSafeRefluxStore';\n\ninterface ProjectsStatsStoreDefinition extends StoreDefinition {\n  getAll(): ProjectsStatsStoreDefinition['itemsBySlug'];\n\n  getBySlug(slug: string): Project;\n  getInitialState(): ProjectsStatsStoreDefinition['itemsBySlug'];\n  itemsBySlug: Record<string, Project>;\n  reset(): void;\n}\n\n/**\n * This is a store specifically used by the dashboard, so that we can\n * clear the store when the Dashboard unmounts\n * (as to not disrupt ProjectsStore which a lot more components use)\n */\nconst storeConfig: ProjectsStatsStoreDefinition = {\n  itemsBySlug: {},\n  unsubscribeListeners: [],\n\n  init() {\n    this.reset();\n\n    this.unsubscribeListeners.push(\n      this.listenTo(ProjectActions.loadStatsForProjectSuccess, this.onStatsLoadSuccess)\n    );\n    this.unsubscribeListeners.push(this.listenTo(ProjectActions.update, this.onUpdate));\n    this.unsubscribeListeners.push(\n      this.listenTo(ProjectActions.updateError, this.onUpdateError)\n    );\n  },\n\n  getInitialState() {\n    return this.itemsBySlug;\n  },\n\n  reset() {\n    this.itemsBySlug = {};\n    this.updatingItems = new Map();\n  },\n\n  onStatsLoadSuccess(projects: Project[]) {\n    projects.forEach(project => {\n      this.itemsBySlug[project.slug] = project;\n    });\n    this.trigger(this.itemsBySlug);\n  },\n\n  /**\n   * Optimistic updates\n   * @param projectSlug Project slug\n   * @param data Project data\n   */\n  onUpdate(projectSlug: string, data: Project) {\n    const project = this.getBySlug(projectSlug);\n    this.updatingItems.set(projectSlug, project);\n    if (!project) {\n      return;\n    }\n\n    const newProject: Project = {\n      ...project,\n      ...data,\n    };\n\n    this.itemsBySlug = {\n      ...this.itemsBySlug,\n      [project.slug]: newProject,\n    };\n    this.trigger(this.itemsBySlug);\n  },\n\n  onUpdateSuccess(data: Project) {\n    // Remove project from updating map\n    this.updatingItems.delete(data.slug);\n  },\n\n  /**\n   * Revert project data when there was an error updating project details\n   * @param err Error object\n   * @param data Previous project data\n   */\n  onUpdateError(_err: Error, projectSlug: string) {\n    const project = this.updatingItems.get(projectSlug);\n    if (!project) {\n      return;\n    }\n\n    this.updatingItems.delete(projectSlug);\n    // Restore old project\n    this.itemsBySlug = {\n      ...this.itemsBySlug,\n      [project.slug]: {...project},\n    };\n    this.trigger(this.itemsBySlug);\n  },\n\n  getAll() {\n    return this.itemsBySlug;\n  },\n\n  getBySlug(slug) {\n    return this.itemsBySlug[slug];\n  },\n};\n\nconst ProjectsStatsStore = createStore(makeSafeRefluxStore(storeConfig));\nexport default ProjectsStatsStore;\n","import Cookies from 'js-cookie';\n\nimport ConfigStore from 'sentry/stores/configStore';\n\nconst SUPERUSER_COOKIE_NAME = 'su';\n\n/**\n * Checking for just isSuperuser on a config object may not be enough as backend often checks for *active* superuser.\n * We therefore check both isSuperuser flag AND superuser session cookie.\n */\nexport function isActiveSuperuser() {\n  const {isSuperuser} = ConfigStore.get('user') || {};\n\n  if (isSuperuser) {\n    /**\n     * Superuser cookie cannot be checked for existence as it is HttpOnly.\n     * As a workaround, we try to change it to something else and if that fails we can assume that it's being present.\n     * There may be an edgecase where it's present and expired but for current usage it's not a big deal.\n     */\n    Cookies.set(SUPERUSER_COOKIE_NAME, 'test');\n\n    if (Cookies.get(SUPERUSER_COOKIE_NAME) === undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n","import {useEffect, useMemo, useRef, useState} from 'react';\nimport uniqBy from 'lodash/uniqBy';\n\nimport {fetchUserTeams} from 'sentry/actionCreators/teams';\nimport TeamActions from 'sentry/actions/teamActions';\nimport {Client} from 'sentry/api';\nimport OrganizationStore from 'sentry/stores/organizationStore';\nimport TeamStore from 'sentry/stores/teamStore';\nimport {useLegacyStore} from 'sentry/stores/useLegacyStore';\nimport {Team} from 'sentry/types';\nimport {isActiveSuperuser} from 'sentry/utils/isActiveSuperuser';\nimport parseLinkHeader from 'sentry/utils/parseLinkHeader';\nimport RequestError from 'sentry/utils/requestError/requestError';\nimport useApi from 'sentry/utils/useApi';\n\ntype State = {\n  /**\n   * The error that occurred if fetching failed\n   */\n  fetchError: null | RequestError;\n  /**\n   * This is state for when fetching data from API\n   */\n  fetching: boolean;\n  /**\n   * Indicates that Team results (from API) are paginated and there are more\n   * Teams that are not in the initial response.\n   */\n  hasMore: null | boolean;\n  /**\n   * Reflects whether or not the initial fetch for the requested teams was\n   * fulfilled\n   */\n  initiallyLoaded: boolean;\n  /**\n   * The last query we searched. Used to validate the cursor\n   */\n  lastSearch: null | string;\n  /**\n   * Pagination\n   */\n  nextCursor?: null | string;\n};\n\ntype Result = {\n  /**\n   * This is an action provided to consumers for them to request more teams\n   * to be loaded. Additional teams will be fetched and loaded into the store.\n   */\n  loadMore: (searchTerm?: string) => Promise<void>;\n  /**\n   * This is an action provided to consumers for them to update the current\n   * teams result set using a simple search query.\n   *\n   * Will always add new options into the store.\n   */\n  onSearch: (searchTerm: string) => Promise<void>;\n  /**\n   * The loaded teams list\n   */\n  teams: Team[];\n} & Pick<State, 'fetching' | 'hasMore' | 'fetchError' | 'initiallyLoaded'>;\n\ntype Options = {\n  /**\n   * When provided, fetches specified teams by id if necessary and only provides those teams.\n   */\n  ids?: string[];\n  /**\n   * Number of teams to return when not using `props.slugs`\n   */\n  limit?: number;\n  /**\n   * When true, fetches user's teams if necessary and only provides user's\n   * teams (isMember = true).\n   */\n  provideUserTeams?: boolean;\n  /**\n   * When provided, fetches specified teams by slug if necessary and only provides those teams.\n   */\n  slugs?: string[];\n};\n\ntype FetchTeamOptions = {\n  cursor?: State['nextCursor'];\n  ids?: string[];\n  lastSearch?: State['lastSearch'];\n  limit?: Options['limit'];\n  search?: State['lastSearch'];\n  slugs?: string[];\n};\n\n/**\n * Helper function to actually load teams\n */\nasync function fetchTeams(\n  api: Client,\n  orgId: string,\n  {slugs, ids, search, limit, lastSearch, cursor}: FetchTeamOptions = {}\n) {\n  const query: {\n    cursor?: typeof cursor;\n    per_page?: number;\n    query?: string;\n  } = {};\n\n  if (slugs !== undefined && slugs.length > 0) {\n    query.query = slugs.map(slug => `slug:${slug}`).join(' ');\n  }\n\n  if (ids !== undefined && ids.length > 0) {\n    query.query = ids.map(id => `id:${id}`).join(' ');\n  }\n\n  if (search) {\n    query.query = `${query.query ?? ''} ${search}`.trim();\n  }\n\n  const isSameSearch = lastSearch === search || (!lastSearch && !search);\n\n  if (isSameSearch && cursor) {\n    query.cursor = cursor;\n  }\n\n  if (limit !== undefined) {\n    query.per_page = limit;\n  }\n\n  let hasMore: null | boolean = false;\n  let nextCursor: null | string = null;\n  const [data, , resp] = await api.requestPromise(`/organizations/${orgId}/teams/`, {\n    includeAllArgs: true,\n    query,\n  });\n\n  const pageLinks = resp?.getResponseHeader('Link');\n  if (pageLinks) {\n    const paginationObject = parseLinkHeader(pageLinks);\n    hasMore = paginationObject?.next?.results;\n    nextCursor = paginationObject?.next?.cursor;\n  }\n\n  return {results: data, hasMore, nextCursor};\n}\n\n// TODO: Paging for items which have already exist in the store is not\n// correctly implemented.\n\n/**\n * Provides teams from the TeamStore\n *\n * This hook also provides a way to select specific slugs to ensure they are\n * loaded, as well as search (type-ahead) for more slugs that may not be in the\n * TeamsStore.\n *\n * NOTE: It is NOT guaranteed that all teams for an organization will be\n * loaded, so you should use this hook with the intention of providing specific\n * slugs, or loading more through search.\n *\n */\nfunction useTeams({limit, slugs, ids, provideUserTeams}: Options = {}) {\n  const api = useApi();\n  const {organization} = useLegacyStore(OrganizationStore);\n  const store = useLegacyStore(TeamStore);\n\n  const orgId = organization?.slug;\n\n  const storeSlugs = new Set(store.teams.map(t => t.slug));\n  const slugsToLoad = slugs?.filter(slug => !storeSlugs.has(slug)) ?? [];\n  const storeIds = new Set(store.teams.map(t => t.id));\n  const idsToLoad = ids?.filter(id => !storeIds.has(id)) ?? [];\n  const shouldLoadSlugs = slugsToLoad.length > 0;\n  const shouldLoadIds = idsToLoad.length > 0;\n  const shouldLoadTeams = provideUserTeams && !store.loadedUserTeams;\n\n  // If we don't need to make a request either for slugs or user teams, set\n  // initiallyLoaded to true\n  const initiallyLoaded = !shouldLoadSlugs && !shouldLoadTeams && !shouldLoadIds;\n\n  const [state, setState] = useState<State>({\n    initiallyLoaded,\n    fetching: false,\n    hasMore: store.hasMore,\n    lastSearch: null,\n    nextCursor: store.cursor,\n    fetchError: null,\n  });\n\n  const slugOrIdRef = useRef<Set<string> | null>(null);\n\n  // Only initialize slugOrIdRef.current once and modify it when we receive new\n  // slugs or ids determined through set equality\n  if (slugs !== undefined || ids !== undefined) {\n    const slugsOrIds = (slugs || ids) ?? [];\n    if (slugOrIdRef.current === null) {\n      slugOrIdRef.current = new Set(slugsOrIds);\n    }\n\n    if (\n      slugsOrIds.length !== slugOrIdRef.current.size ||\n      slugsOrIds.some(slugOrId => !slugOrIdRef.current?.has(slugOrId))\n    ) {\n      slugOrIdRef.current = new Set(slugsOrIds);\n    }\n  }\n\n  async function loadUserTeams() {\n    if (orgId === undefined) {\n      return;\n    }\n\n    setState({...state, fetching: true});\n    try {\n      await fetchUserTeams(api, {orgId});\n\n      setState({...state, fetching: false, initiallyLoaded: true});\n    } catch (err) {\n      console.error(err); // eslint-disable-line no-console\n\n      setState({...state, fetching: false, initiallyLoaded: true, fetchError: err});\n    }\n  }\n\n  async function loadTeamsBySlugOrId() {\n    if (orgId === undefined) {\n      return;\n    }\n\n    setState({...state, fetching: true});\n    try {\n      const {results, hasMore, nextCursor} = await fetchTeams(api, orgId, {\n        slugs: slugsToLoad,\n        ids: idsToLoad,\n        limit,\n      });\n\n      // Unique by `id` to avoid duplicates due to renames and state store data\n      const fetchedTeams = uniqBy([...results, ...store.teams], ({id}) => id);\n      TeamActions.loadTeams(fetchedTeams);\n\n      setState({\n        ...state,\n        hasMore,\n        fetching: false,\n        initiallyLoaded: true,\n        nextCursor,\n      });\n    } catch (err) {\n      console.error(err); // eslint-disable-line no-console\n\n      setState({...state, fetching: false, initiallyLoaded: true, fetchError: err});\n    }\n  }\n\n  function handleSearch(search: string) {\n    if (search !== '') {\n      return handleFetchAdditionalTeams(search);\n    }\n\n    // Reset pagination state to match store if doing an empty search\n    if (state.hasMore !== store.hasMore || state.nextCursor !== store.cursor) {\n      setState({\n        ...state,\n        lastSearch: search,\n        hasMore: store.hasMore,\n        nextCursor: store.cursor,\n      });\n    }\n\n    return Promise.resolve();\n  }\n\n  async function handleFetchAdditionalTeams(search?: string) {\n    const {lastSearch} = state;\n    // Use the store cursor if there is no search keyword provided\n    const cursor = search ? state.nextCursor : store.cursor;\n\n    if (orgId === undefined) {\n      // eslint-disable-next-line no-console\n      console.error('Cannot fetch teams without an organization in context');\n      return;\n    }\n\n    setState({...state, fetching: true});\n\n    try {\n      api.clear();\n      const {results, hasMore, nextCursor} = await fetchTeams(api, orgId, {\n        search,\n        limit,\n        lastSearch,\n        cursor,\n      });\n\n      const fetchedTeams = uniqBy([...store.teams, ...results], ({slug}) => slug);\n\n      if (search) {\n        // Only update the store if we have more items\n        if (fetchedTeams.length > store.teams.length) {\n          TeamActions.loadTeams(fetchedTeams);\n        }\n      } else {\n        // If we fetched a page of teams without a search query, add cursor data to the store\n        TeamActions.loadTeams(fetchedTeams, hasMore, nextCursor);\n      }\n\n      setState({\n        ...state,\n        hasMore: hasMore && store.hasMore,\n        fetching: false,\n        lastSearch: search ?? null,\n        nextCursor,\n      });\n    } catch (err) {\n      console.error(err); // eslint-disable-line no-console\n\n      setState({...state, fetching: false, fetchError: err});\n    }\n  }\n\n  useEffect(() => {\n    // Load specified team slugs\n    if (shouldLoadSlugs || shouldLoadIds) {\n      loadTeamsBySlugOrId();\n      return;\n    }\n\n    // Load user teams\n    if (shouldLoadTeams) {\n      loadUserTeams();\n    }\n  }, [slugOrIdRef.current, provideUserTeams]);\n\n  const isSuperuser = isActiveSuperuser();\n\n  const filteredTeams = useMemo(() => {\n    return slugs\n      ? store.teams.filter(t => slugs.includes(t.slug))\n      : ids\n      ? store.teams.filter(t => ids.includes(t.id))\n      : provideUserTeams && !isSuperuser\n      ? store.teams.filter(t => t.isMember)\n      : store.teams;\n  }, [store.teams, ids, slugs, provideUserTeams, isSuperuser]);\n\n  const result: Result = {\n    teams: filteredTeams,\n    fetching: state.fetching || store.loading,\n    initiallyLoaded: state.initiallyLoaded,\n    fetchError: state.fetchError,\n    hasMore: state.hasMore ?? store.hasMore,\n    onSearch: handleSearch,\n    loadMore: handleFetchAdditionalTeams,\n  };\n\n  return result;\n}\n\nexport default useTeams;\n"],"names":["update","api","params","ProjectActions","projectId","data","endpoint","orgId","requestPromise","method","then","err","loadStats","request","query","success","error","_projectStatsToFetch","Set","_debouncedLoadStats","debounce","projectSet","storedProjects","ProjectsStatsStore","existingProjectStats","Object","values","map","id","projects","Array","from","filter","project","includes","length","clear","queries","chunk","chunkedProjects","additionalQuery","statsPeriod","join","_queryForStats","Promise","all","results","reduce","acc","result","concat","catch","addErrorMessage","t","loadStatsForProject","add","setActiveProject","removeProject","slug","addSuccessMessage","tct","transferProject","email","message","status","responseJSON","detail","addTeamToProject","orgSlug","projectSlug","team","addLoadingMessage","removeTeamFromProject","teamSlug","changeProjectSlug","prev","next","createProject","name","platform","options","default_rules","defaultRules","loadDocs","fetchProjectsCount","async","fetchAnyReleaseExistence","per_page","doCallback","args","callIfFunction","fetchUserTeams","teams","TeamActions","updateTeamSuccess","teamId","joinTeam","memberId","uniqueId","leaveTeam","createTeam","organization","removeTeam","storeConfig","itemsBySlug","unsubscribeListeners","init","this","reset","push","listenTo","onStatsLoadSuccess","onUpdate","onUpdateError","getInitialState","updatingItems","Map","forEach","trigger","getBySlug","set","newProject","onUpdateSuccess","delete","_err","get","getAll","createStore","makeSafeRefluxStore","isActiveSuperuser","isSuperuser","ConfigStore","Cookies","undefined","fetchTeams","slugs","ids","search","limit","lastSearch","cursor","trim","isSameSearch","hasMore","nextCursor","resp","includeAllArgs","pageLinks","getResponseHeader","paginationObject","parseLinkHeader","provideUserTeams","useApi","useLegacyStore","OrganizationStore","store","TeamStore","storeSlugs","slugsToLoad","has","storeIds","idsToLoad","shouldLoadSlugs","shouldLoadIds","shouldLoadTeams","loadedUserTeams","initiallyLoaded","state","setState","useState","fetching","fetchError","slugOrIdRef","useRef","slugsOrIds","current","size","some","slugOrId","loadUserTeams","console","loadTeamsBySlugOrId","fetchedTeams","uniqBy","handleSearch","handleFetchAdditionalTeams","resolve","useEffect","filteredTeams","useMemo","isMember","loading","onSearch","loadMore"],"sourceRoot":""}