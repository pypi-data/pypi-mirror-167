{"version":3,"file":"chunks/app_utils_performance_urls_ts.xxxxxxxxxxxxxxxxxxxx.js","mappings":"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","sources":["webpack:///./app/components/events/interfaces/spans/utils.tsx","webpack:///./app/utils/performance/urls.ts"],"sourcesContent":["import {browserHistory} from 'react-router';\nimport {Location} from 'history';\nimport isNumber from 'lodash/isNumber';\nimport isString from 'lodash/isString';\nimport maxBy from 'lodash/maxBy';\nimport set from 'lodash/set';\nimport moment from 'moment';\n\nimport {\n  TOGGLE_BORDER_BOX,\n  TOGGLE_BUTTON_MAX_WIDTH,\n} from 'sentry/components/performance/waterfall/treeConnector';\nimport {Organization} from 'sentry/types';\nimport {EntryType, EventTransaction} from 'sentry/types/event';\nimport {assert} from 'sentry/types/utils';\nimport trackAdvancedAnalyticsEvent from 'sentry/utils/analytics/trackAdvancedAnalyticsEvent';\nimport {WebVital} from 'sentry/utils/fields';\nimport {TraceError} from 'sentry/utils/performance/quickTrace/types';\nimport {WEB_VITAL_DETAILS} from 'sentry/utils/performance/vitals/constants';\nimport {getPerformanceTransaction} from 'sentry/utils/performanceForSentry';\nimport {Theme} from 'sentry/utils/theme';\n\nimport {MERGE_LABELS_THRESHOLD_PERCENT} from './constants';\nimport SpanTreeModel from './spanTreeModel';\nimport {\n  EnhancedSpan,\n  GapSpanType,\n  OrphanSpanType,\n  OrphanTreeDepth,\n  ParsedTraceType,\n  ProcessedSpanType,\n  RawSpanType,\n  SpanEntry,\n  SpanType,\n  TraceContextType,\n  TreeDepthType,\n} from './types';\n\nexport const isValidSpanID = (maybeSpanID: any) =>\n  isString(maybeSpanID) && maybeSpanID.length > 0;\n\nexport const setSpansOnTransaction = (spanCount: number) => {\n  const transaction = getPerformanceTransaction();\n\n  if (!transaction || spanCount === 0) {\n    return;\n  }\n\n  const spanCountGroups = [10, 100, 200, 300, 400, 500, 600, 700, 800, 900, 1001];\n  const spanGroup = spanCountGroups.find(g => spanCount <= g) || -1;\n\n  transaction.setTag('ui.spanCount', spanCount);\n  transaction.setTag('ui.spanCount.grouped', `<=${spanGroup}`);\n};\n\nexport type SpanBoundsType = {endTimestamp: number; startTimestamp: number};\nexport type SpanGeneratedBoundsType =\n  | {isSpanVisibleInView: boolean; type: 'TRACE_TIMESTAMPS_EQUAL'}\n  | {isSpanVisibleInView: boolean; type: 'INVALID_VIEW_WINDOW'}\n  | {\n      isSpanVisibleInView: boolean;\n      start: number;\n      type: 'TIMESTAMPS_EQUAL';\n      width: number;\n    }\n  | {\n      end: number;\n      isSpanVisibleInView: boolean;\n      start: number;\n      type: 'TIMESTAMPS_REVERSED';\n    }\n  | {\n      end: number;\n      isSpanVisibleInView: boolean;\n      start: number;\n      type: 'TIMESTAMPS_STABLE';\n    };\n\nexport type SpanViewBoundsType = {\n  isSpanVisibleInView: boolean;\n  left: undefined | number;\n  warning: undefined | string;\n  width: undefined | number;\n};\n\nconst normalizeTimestamps = (spanBounds: SpanBoundsType): SpanBoundsType => {\n  const {startTimestamp, endTimestamp} = spanBounds;\n\n  if (startTimestamp > endTimestamp) {\n    return {startTimestamp: endTimestamp, endTimestamp: startTimestamp};\n  }\n\n  return spanBounds;\n};\n\nexport enum TimestampStatus {\n  Stable,\n  Reversed,\n  Equal,\n}\n\nexport const parseSpanTimestamps = (spanBounds: SpanBoundsType): TimestampStatus => {\n  const startTimestamp: number = spanBounds.startTimestamp;\n  const endTimestamp: number = spanBounds.endTimestamp;\n\n  if (startTimestamp < endTimestamp) {\n    return TimestampStatus.Stable;\n  }\n\n  if (startTimestamp === endTimestamp) {\n    return TimestampStatus.Equal;\n  }\n\n  return TimestampStatus.Reversed;\n};\n\n// given the start and end trace timestamps, and the view window, we want to generate a function\n// that'll output the relative %'s for the width and placements relative to the left-hand side.\n//\n// The view window (viewStart and viewEnd) are percentage values (between 0% and 100%), they correspond to the window placement\n// between the start and end trace timestamps.\nexport const boundsGenerator = (bounds: {\n  // unix timestamp\n  traceEndTimestamp: number;\n  traceStartTimestamp: number;\n  // in [0, 1]\n  viewEnd: number;\n  // unix timestamp\n  viewStart: number; // in [0, 1]\n}) => {\n  const {viewStart, viewEnd} = bounds;\n\n  const {startTimestamp: traceStartTimestamp, endTimestamp: traceEndTimestamp} =\n    normalizeTimestamps({\n      startTimestamp: bounds.traceStartTimestamp,\n      endTimestamp: bounds.traceEndTimestamp,\n    });\n\n  // viewStart and viewEnd are percentage values (%) of the view window relative to the left\n  // side of the trace view minimap\n\n  // invariant: viewStart <= viewEnd\n\n  // duration of the entire trace in seconds\n  const traceDuration = traceEndTimestamp - traceStartTimestamp;\n\n  const viewStartTimestamp = traceStartTimestamp + viewStart * traceDuration;\n  const viewEndTimestamp = traceEndTimestamp - (1 - viewEnd) * traceDuration;\n  const viewDuration = viewEndTimestamp - viewStartTimestamp;\n\n  return (spanBounds: SpanBoundsType): SpanGeneratedBoundsType => {\n    // TODO: alberto.... refactor so this is impossible 😠\n    if (traceDuration <= 0) {\n      return {\n        type: 'TRACE_TIMESTAMPS_EQUAL',\n        isSpanVisibleInView: true,\n      };\n    }\n\n    if (viewDuration <= 0) {\n      return {\n        type: 'INVALID_VIEW_WINDOW',\n        isSpanVisibleInView: true,\n      };\n    }\n\n    const {startTimestamp, endTimestamp} = normalizeTimestamps(spanBounds);\n\n    const timestampStatus = parseSpanTimestamps(spanBounds);\n\n    const start = (startTimestamp - viewStartTimestamp) / viewDuration;\n    const end = (endTimestamp - viewStartTimestamp) / viewDuration;\n\n    const isSpanVisibleInView = end > 0 && start < 1;\n\n    switch (timestampStatus) {\n      case TimestampStatus.Equal: {\n        return {\n          type: 'TIMESTAMPS_EQUAL',\n          start,\n          width: 1,\n          // a span bar is visible even if they're at the extreme ends of the view selection.\n          // these edge cases are:\n          // start == end == 0, and\n          // start == end == 1\n          isSpanVisibleInView: end >= 0 && start <= 1,\n        };\n      }\n      case TimestampStatus.Reversed: {\n        return {\n          type: 'TIMESTAMPS_REVERSED',\n          start,\n          end,\n          isSpanVisibleInView,\n        };\n      }\n      case TimestampStatus.Stable: {\n        return {\n          type: 'TIMESTAMPS_STABLE',\n          start,\n          end,\n          isSpanVisibleInView,\n        };\n      }\n      default: {\n        const _exhaustiveCheck: never = timestampStatus;\n        return _exhaustiveCheck;\n      }\n    }\n  };\n};\n\nexport function generateRootSpan(trace: ParsedTraceType): RawSpanType {\n  const rootSpan: RawSpanType = {\n    trace_id: trace.traceID,\n    span_id: trace.rootSpanID,\n    parent_span_id: trace.parentSpanID,\n    start_timestamp: trace.traceStartTimestamp,\n    timestamp: trace.traceEndTimestamp,\n    op: trace.op,\n    description: trace.description,\n    data: {},\n    status: trace.rootSpanStatus,\n    hash: trace.hash,\n    exclusive_time: trace.exclusiveTime,\n  };\n\n  return rootSpan;\n}\n\n// start and end are assumed to be unix timestamps with fractional seconds\nexport function getTraceDateTimeRange(input: {end: number; start: number}): {\n  end: string;\n  start: string;\n} {\n  const start = moment\n    .unix(input.start)\n    .subtract(12, 'hours')\n    .utc()\n    .format('YYYY-MM-DDTHH:mm:ss.SSS');\n\n  const end = moment\n    .unix(input.end)\n    .add(12, 'hours')\n    .utc()\n    .format('YYYY-MM-DDTHH:mm:ss.SSS');\n\n  return {\n    start,\n    end,\n  };\n}\n\nexport function isGapSpan(span: ProcessedSpanType): span is GapSpanType {\n  if ('type' in span) {\n    return span.type === 'gap';\n  }\n\n  return false;\n}\n\nexport function isOrphanSpan(span: ProcessedSpanType): span is OrphanSpanType {\n  if ('type' in span) {\n    if (span.type === 'orphan') {\n      return true;\n    }\n\n    if (span.type === 'gap') {\n      return span.isOrphan;\n    }\n  }\n\n  return false;\n}\n\nexport function getSpanID(span: ProcessedSpanType, defaultSpanID: string = ''): string {\n  if (isGapSpan(span)) {\n    return defaultSpanID;\n  }\n\n  return span.span_id;\n}\n\nexport function getSpanOperation(span: ProcessedSpanType): string | undefined {\n  if (isGapSpan(span)) {\n    return undefined;\n  }\n\n  return span.op;\n}\n\nexport function getSpanTraceID(span: ProcessedSpanType): string {\n  if (isGapSpan(span)) {\n    return 'gap-span';\n  }\n\n  return span.trace_id;\n}\n\nexport function getSpanParentSpanID(span: ProcessedSpanType): string | undefined {\n  if (isGapSpan(span)) {\n    return 'gap-span';\n  }\n\n  return span.parent_span_id;\n}\n\nexport function getTraceContext(\n  event: Readonly<EventTransaction>\n): TraceContextType | undefined {\n  return event?.contexts?.trace;\n}\n\nexport function parseTrace(event: Readonly<EventTransaction>): ParsedTraceType {\n  const spanEntry = event.entries.find((entry: SpanEntry | any): entry is SpanEntry => {\n    return entry.type === EntryType.SPANS;\n  });\n\n  const spans: Array<RawSpanType> = spanEntry?.data ?? [];\n\n  const traceContext = getTraceContext(event);\n  const traceID = (traceContext && traceContext.trace_id) || '';\n  const rootSpanID = (traceContext && traceContext.span_id) || '';\n  const rootSpanOpName = (traceContext && traceContext.op) || 'transaction';\n  const description = traceContext && traceContext.description;\n  const parentSpanID = traceContext && traceContext.parent_span_id;\n  const rootSpanStatus = traceContext && traceContext.status;\n  const hash = traceContext && traceContext.hash;\n  const exclusiveTime = traceContext && traceContext.exclusive_time;\n\n  if (!spanEntry || spans.length <= 0) {\n    return {\n      op: rootSpanOpName,\n      childSpans: {},\n      traceStartTimestamp: event.startTimestamp,\n      traceEndTimestamp: event.endTimestamp,\n      traceID,\n      rootSpanID,\n      rootSpanStatus,\n      parentSpanID,\n      spans: [],\n      description,\n      hash,\n      exclusiveTime,\n    };\n  }\n\n  // any span may be a parent of another span\n  const potentialParents = new Set(\n    spans.map(span => {\n      return span.span_id;\n    })\n  );\n\n  // the root transaction span is a parent of all other spans\n  potentialParents.add(rootSpanID);\n\n  // we reduce spans to become an object mapping span ids to their children\n\n  const init: ParsedTraceType = {\n    op: rootSpanOpName,\n    childSpans: {},\n    traceStartTimestamp: event.startTimestamp,\n    traceEndTimestamp: event.endTimestamp,\n    traceID,\n    rootSpanID,\n    rootSpanStatus,\n    parentSpanID,\n    spans,\n    description,\n    hash,\n    exclusiveTime,\n  };\n\n  const reduced: ParsedTraceType = spans.reduce((acc, inputSpan) => {\n    let span: SpanType = inputSpan;\n\n    const parentSpanId = getSpanParentSpanID(span);\n\n    const hasParent = parentSpanId && potentialParents.has(parentSpanId);\n\n    if (!isValidSpanID(parentSpanId) || !hasParent) {\n      // this span is considered an orphan with respect to the spans within this transaction.\n      // although the span is an orphan, it's still a descendant of this transaction,\n      // so we set its parent span id to be the root transaction span's id\n      span.parent_span_id = rootSpanID;\n\n      span = {\n        type: 'orphan',\n        ...span,\n      } as OrphanSpanType;\n    }\n\n    assert(span.parent_span_id);\n\n    // get any span children whose parent_span_id is equal to span.parent_span_id,\n    // otherwise start with an empty array\n    const spanChildren: Array<SpanType> = acc.childSpans[span.parent_span_id] ?? [];\n\n    spanChildren.push(span);\n\n    set(acc.childSpans, span.parent_span_id, spanChildren);\n\n    // set trace start & end timestamps based on given span's start and end timestamps\n\n    if (!acc.traceStartTimestamp || span.start_timestamp < acc.traceStartTimestamp) {\n      acc.traceStartTimestamp = span.start_timestamp;\n    }\n\n    // establish trace end timestamp\n\n    const hasEndTimestamp = isNumber(span.timestamp);\n\n    if (!acc.traceEndTimestamp) {\n      if (hasEndTimestamp) {\n        acc.traceEndTimestamp = span.timestamp;\n        return acc;\n      }\n\n      acc.traceEndTimestamp = span.start_timestamp;\n      return acc;\n    }\n\n    if (hasEndTimestamp && span.timestamp! > acc.traceEndTimestamp) {\n      acc.traceEndTimestamp = span.timestamp;\n      return acc;\n    }\n\n    if (span.start_timestamp > acc.traceEndTimestamp) {\n      acc.traceEndTimestamp = span.start_timestamp;\n    }\n\n    return acc;\n  }, init);\n\n  // sort span children\n\n  Object.values(reduced.childSpans).forEach(spanChildren => {\n    spanChildren.sort(sortSpans);\n  });\n\n  return reduced;\n}\n\nfunction sortSpans(firstSpan: SpanType, secondSpan: SpanType) {\n  // orphan spans come after non-orphan spans.\n\n  if (isOrphanSpan(firstSpan) && !isOrphanSpan(secondSpan)) {\n    // sort secondSpan before firstSpan\n    return 1;\n  }\n\n  if (!isOrphanSpan(firstSpan) && isOrphanSpan(secondSpan)) {\n    // sort firstSpan before secondSpan\n    return -1;\n  }\n\n  // sort spans by their start timestamp in ascending order\n\n  if (firstSpan.start_timestamp < secondSpan.start_timestamp) {\n    // sort firstSpan before secondSpan\n    return -1;\n  }\n\n  if (firstSpan.start_timestamp === secondSpan.start_timestamp) {\n    return 0;\n  }\n\n  // sort secondSpan before firstSpan\n  return 1;\n}\n\nexport function isOrphanTreeDepth(\n  treeDepth: TreeDepthType\n): treeDepth is OrphanTreeDepth {\n  if (typeof treeDepth === 'number') {\n    return false;\n  }\n  return treeDepth?.type === 'orphan';\n}\n\nexport function unwrapTreeDepth(treeDepth: TreeDepthType): number {\n  if (isOrphanTreeDepth(treeDepth)) {\n    return treeDepth.depth;\n  }\n\n  return treeDepth;\n}\n\nexport function isEventFromBrowserJavaScriptSDK(event: EventTransaction): boolean {\n  const sdkName = event.sdk?.name;\n  if (!sdkName) {\n    return false;\n  }\n  // based on https://github.com/getsentry/sentry-javascript/blob/master/packages/browser/src/version.ts\n  return [\n    'sentry.javascript.browser',\n    'sentry.javascript.react',\n    'sentry.javascript.gatsby',\n    'sentry.javascript.ember',\n    'sentry.javascript.vue',\n    'sentry.javascript.angular',\n    'sentry.javascript.nextjs',\n    'sentry.javascript.electron',\n    'sentry.javascript.remix',\n    'sentry.javascript.svelte',\n  ].includes(sdkName.toLowerCase());\n}\n\n// Durationless ops from: https://github.com/getsentry/sentry-javascript/blob/0defcdcc2dfe719343efc359d58c3f90743da2cd/packages/apm/src/integrations/tracing.ts#L629-L688\n// PerformanceMark: Duration is 0 as per https://developer.mozilla.org/en-US/docs/Web/API/PerformanceMark\n// PerformancePaintTiming: Duration is 0 as per https://developer.mozilla.org/en-US/docs/Web/API/PerformancePaintTiming\nexport const durationlessBrowserOps = ['mark', 'paint'];\n\ntype Measurements = {\n  [name: string]: {\n    failedThreshold: boolean;\n    timestamp: number;\n    value: number | undefined;\n  };\n};\n\ntype VerticalMark = {\n  failedThreshold: boolean;\n  marks: Measurements;\n};\n\nfunction hasFailedThreshold(marks: Measurements): boolean {\n  const names = Object.keys(marks);\n  const records = Object.values(WEB_VITAL_DETAILS).filter(vital =>\n    names.includes(vital.slug)\n  );\n\n  return records.some(record => {\n    const {value} = marks[record.slug];\n    if (typeof value === 'number' && typeof record.poorThreshold === 'number') {\n      return value >= record.poorThreshold;\n    }\n    return false;\n  });\n}\n\nexport function getMeasurements(\n  event: EventTransaction,\n  generateBounds: (bounds: SpanBoundsType) => SpanGeneratedBoundsType\n): Map<number, VerticalMark> {\n  if (!event.measurements || !event.startTimestamp) {\n    return new Map();\n  }\n\n  const {startTimestamp} = event;\n\n  // Note: CLS and INP should not be included here, since they are not timeline-based measurements.\n  const allowedVitals = new Set<string>([\n    WebVital.FCP,\n    WebVital.FP,\n    WebVital.FID,\n    WebVital.LCP,\n    WebVital.TTFB,\n  ]);\n\n  const measurements = Object.keys(event.measurements)\n    .filter(name => allowedVitals.has(`measurements.${name}`))\n    .map(name => {\n      const associatedMeasurement = event.measurements![name];\n      return {\n        name,\n        // Time timestamp is in seconds, but the measurement value is given in ms so convert it here\n        timestamp: startTimestamp + associatedMeasurement.value / 1000,\n        value: associatedMeasurement ? associatedMeasurement.value : undefined,\n      };\n    });\n\n  const mergedMeasurements = new Map<number, VerticalMark>();\n\n  measurements.forEach(measurement => {\n    const name = measurement.name;\n    const value = measurement.value;\n\n    const bounds = generateBounds({\n      startTimestamp: measurement.timestamp,\n      endTimestamp: measurement.timestamp,\n    });\n\n    // This condition will never be hit, since we're using the same value for start and end in generateBounds\n    // I've put this condition here to prevent the TS linter from complaining\n    if (bounds.type !== 'TIMESTAMPS_EQUAL') {\n      return;\n    }\n\n    const roundedPos = Math.round(bounds.start * 100);\n\n    // Compare this position with the position of the other measurements, to determine if\n    // they are close enough to be bucketed together\n\n    for (const [otherPos] of mergedMeasurements) {\n      const positionDelta = Math.abs(otherPos - roundedPos);\n      if (positionDelta <= MERGE_LABELS_THRESHOLD_PERCENT) {\n        const verticalMark = mergedMeasurements.get(otherPos)!;\n\n        const {poorThreshold} = WEB_VITAL_DETAILS[`measurements.${name}`];\n\n        verticalMark.marks = {\n          ...verticalMark.marks,\n          [name]: {\n            value,\n            timestamp: measurement.timestamp,\n            failedThreshold: value ? value >= poorThreshold : false,\n          },\n        };\n\n        if (!verticalMark.failedThreshold) {\n          verticalMark.failedThreshold = hasFailedThreshold(verticalMark.marks);\n        }\n\n        mergedMeasurements.set(otherPos, verticalMark);\n        return;\n      }\n    }\n\n    const {poorThreshold} = WEB_VITAL_DETAILS[`measurements.${name}`];\n\n    const marks = {\n      [name]: {\n        value,\n        timestamp: measurement.timestamp,\n        failedThreshold: value ? value >= poorThreshold : false,\n      },\n    };\n\n    mergedMeasurements.set(roundedPos, {\n      marks,\n      failedThreshold: hasFailedThreshold(marks),\n    });\n  });\n\n  return mergedMeasurements;\n}\n\nexport function getMeasurementBounds(\n  timestamp: number,\n  generateBounds: (bounds: SpanBoundsType) => SpanGeneratedBoundsType\n): SpanViewBoundsType {\n  const bounds = generateBounds({\n    startTimestamp: timestamp,\n    endTimestamp: timestamp,\n  });\n\n  switch (bounds.type) {\n    case 'TRACE_TIMESTAMPS_EQUAL':\n    case 'INVALID_VIEW_WINDOW': {\n      return {\n        warning: undefined,\n        left: undefined,\n        width: undefined,\n        isSpanVisibleInView: bounds.isSpanVisibleInView,\n      };\n    }\n    case 'TIMESTAMPS_EQUAL': {\n      return {\n        warning: undefined,\n        left: bounds.start,\n        width: 0.00001,\n        isSpanVisibleInView: bounds.isSpanVisibleInView,\n      };\n    }\n    case 'TIMESTAMPS_REVERSED': {\n      return {\n        warning: undefined,\n        left: bounds.start,\n        width: bounds.end - bounds.start,\n        isSpanVisibleInView: bounds.isSpanVisibleInView,\n      };\n    }\n    case 'TIMESTAMPS_STABLE': {\n      return {\n        warning: void 0,\n        left: bounds.start,\n        width: bounds.end - bounds.start,\n        isSpanVisibleInView: bounds.isSpanVisibleInView,\n      };\n    }\n    default: {\n      const _exhaustiveCheck: never = bounds;\n      return _exhaustiveCheck;\n    }\n  }\n}\n\nexport function scrollToSpan(\n  spanId: string,\n  scrollToHash: (hash: string) => void,\n  location: Location,\n  organization: Organization\n) {\n  return (e: React.MouseEvent<Element>) => {\n    // do not use the default anchor behaviour\n    // because it will be hidden behind the minimap\n    e.preventDefault();\n\n    const hash = spanTargetHash(spanId);\n\n    scrollToHash(hash);\n\n    // TODO(txiao): This is causing a rerender of the whole page,\n    // which can be slow.\n    //\n    // make sure to update the location\n    browserHistory.push({\n      ...location,\n      hash,\n    });\n\n    trackAdvancedAnalyticsEvent('performance_views.event_details.anchor_span', {\n      organization,\n      span_id: spanId,\n    });\n  };\n}\n\nexport function spanTargetHash(spanId: string): string {\n  return `#span-${spanId}`;\n}\n\nexport function getSiblingGroupKey(span: SpanType, occurrence?: number): string {\n  if (occurrence !== undefined) {\n    return `${span.op}.${span.description}.${occurrence}`;\n  }\n\n  return `${span.op}.${span.description}`;\n}\n\nexport function getSpanGroupTimestamps(spanGroup: EnhancedSpan[]) {\n  return spanGroup.reduce(\n    (acc, spanGroupItem) => {\n      const {start_timestamp, timestamp} = spanGroupItem.span;\n\n      let newStartTimestamp = acc.startTimestamp;\n      let newEndTimestamp = acc.endTimestamp;\n\n      if (start_timestamp < newStartTimestamp) {\n        newStartTimestamp = start_timestamp;\n      }\n\n      if (newEndTimestamp < timestamp) {\n        newEndTimestamp = timestamp;\n      }\n\n      return {\n        startTimestamp: newStartTimestamp,\n        endTimestamp: newEndTimestamp,\n      };\n    },\n    {\n      startTimestamp: spanGroup[0].span.start_timestamp,\n      endTimestamp: spanGroup[0].span.timestamp,\n    }\n  );\n}\n\nexport function getSpanGroupBounds(\n  spanGroup: EnhancedSpan[],\n  generateBounds: (bounds: SpanBoundsType) => SpanGeneratedBoundsType\n): SpanViewBoundsType {\n  const {startTimestamp, endTimestamp} = getSpanGroupTimestamps(spanGroup);\n\n  const bounds = generateBounds({\n    startTimestamp,\n    endTimestamp,\n  });\n\n  switch (bounds.type) {\n    case 'TRACE_TIMESTAMPS_EQUAL':\n    case 'INVALID_VIEW_WINDOW': {\n      return {\n        warning: void 0,\n        left: void 0,\n        width: void 0,\n        isSpanVisibleInView: bounds.isSpanVisibleInView,\n      };\n    }\n    case 'TIMESTAMPS_EQUAL': {\n      return {\n        warning: void 0,\n        left: bounds.start,\n        width: 0.00001,\n        isSpanVisibleInView: bounds.isSpanVisibleInView,\n      };\n    }\n    case 'TIMESTAMPS_REVERSED':\n    case 'TIMESTAMPS_STABLE': {\n      return {\n        warning: void 0,\n        left: bounds.start,\n        width: bounds.end - bounds.start,\n        isSpanVisibleInView: bounds.isSpanVisibleInView,\n      };\n    }\n    default: {\n      const _exhaustiveCheck: never = bounds;\n      return _exhaustiveCheck;\n    }\n  }\n}\n\nexport class SpansInViewMap {\n  spanDepthsInView: Map<string, number>;\n  treeDepthSum: number;\n  length: number;\n  isRootSpanInView: boolean;\n\n  constructor(isRootSpanInView: boolean) {\n    this.spanDepthsInView = new Map();\n    this.treeDepthSum = 0;\n    this.length = 0;\n    this.isRootSpanInView = isRootSpanInView;\n  }\n\n  /**\n   *\n   * @param spanId\n   * @param treeDepth\n   * @returns false if the span is already stored, true otherwise\n   */\n  addSpan(spanId: string, treeDepth: number): boolean {\n    if (this.spanDepthsInView.has(spanId)) {\n      return false;\n    }\n\n    this.spanDepthsInView.set(spanId, treeDepth);\n    this.length += 1;\n    this.treeDepthSum += treeDepth;\n\n    if (treeDepth === 0) {\n      this.isRootSpanInView = true;\n    }\n\n    return true;\n  }\n\n  /**\n   *\n   * @param spanId\n   * @returns false if the span does not exist within the span, true otherwise\n   */\n  removeSpan(spanId: string): boolean {\n    if (!this.spanDepthsInView.has(spanId)) {\n      return false;\n    }\n\n    const treeDepth = this.spanDepthsInView.get(spanId);\n    this.spanDepthsInView.delete(spanId);\n    this.length -= 1;\n    this.treeDepthSum -= treeDepth!;\n\n    if (treeDepth === 0) {\n      this.isRootSpanInView = false;\n    }\n\n    return true;\n  }\n\n  has(spanId: string) {\n    return this.spanDepthsInView.has(spanId);\n  }\n\n  getScrollVal() {\n    if (this.isRootSpanInView) {\n      return 0;\n    }\n\n    const avgDepth = Math.round(this.treeDepthSum / this.length);\n    return avgDepth * (TOGGLE_BORDER_BOX / 2) - TOGGLE_BUTTON_MAX_WIDTH / 2;\n  }\n}\n\nexport function getCumulativeAlertLevelFromErrors(\n  errors?: Pick<TraceError, 'level'>[]\n): keyof Theme['alert'] | undefined {\n  const highestErrorLevel = maxBy(\n    errors || [],\n    error => ERROR_LEVEL_WEIGHTS[error.level]\n  )?.level;\n\n  if (!highestErrorLevel) {\n    return undefined;\n  }\n  return ERROR_LEVEL_TO_ALERT_TYPE[highestErrorLevel];\n}\n\n// Maps the known error levels to an Alert component types\nconst ERROR_LEVEL_TO_ALERT_TYPE: Record<TraceError['level'], keyof Theme['alert']> = {\n  fatal: 'error',\n  error: 'error',\n  default: 'error',\n  warning: 'warning',\n  sample: 'info',\n  info: 'info',\n  unknown: 'muted',\n};\n\n// Allows sorting errors according to their level of severity\nconst ERROR_LEVEL_WEIGHTS: Record<TraceError['level'], number> = {\n  fatal: 5,\n  error: 4,\n  default: 4,\n  warning: 3,\n  sample: 2,\n  info: 1,\n  unknown: 0,\n};\n\n/**\n * Formats start and end unix timestamps by inserting a leading and trailing zero if needed, so they can have the same length\n */\nexport function getFormattedTimeRangeWithLeadingAndTrailingZero(\n  start: number,\n  end: number\n) {\n  const startStrings = String(start).split('.');\n  const endStrings = String(end).split('.');\n\n  if (startStrings.length !== 2 || endStrings.length !== 2) {\n    return {\n      start: String(start),\n      end: String(end),\n    };\n  }\n\n  const newTimestamps = startStrings.reduce(\n    (acc, startString, index) => {\n      if (startString.length > endStrings[index].length) {\n        acc.start.push(startString);\n        acc.end.push(\n          index === 0\n            ? endStrings[index].padStart(startString.length, '0')\n            : endStrings[index].padEnd(startString.length, '0')\n        );\n        return acc;\n      }\n\n      acc.start.push(\n        index === 0\n          ? startString.padStart(endStrings[index].length, '0')\n          : startString.padEnd(endStrings[index].length, '0')\n      );\n      acc.end.push(endStrings[index]);\n      return acc;\n    },\n    {start: [], end: []} as {\n      end: string[];\n      start: string[];\n    }\n  );\n\n  return {\n    start: newTimestamps.start.join('.'),\n    end: newTimestamps.end.join('.'),\n  };\n}\n\nexport function groupShouldBeHidden(\n  group: SpanTreeModel[],\n  focusedSpanIDs: Set<string> | undefined\n) {\n  if (!focusedSpanIDs) {\n    return false;\n  }\n\n  // If none of the spans in this group are focused, the group should be hidden\n  return !group.some(spanModel => focusedSpanIDs.has(spanModel.span.span_id));\n}\n","import {LocationDescriptor, Query} from 'history';\n\nimport {spanTargetHash} from 'sentry/components/events/interfaces/spans/utils';\nimport {Organization} from 'sentry/types';\nimport {defined} from 'sentry/utils';\n\nexport function getTransactionDetailsUrl(\n  orgSlug: Organization['slug'],\n  eventSlug: string,\n  transaction?: string,\n  query?: Query,\n  spanId?: string\n): LocationDescriptor {\n  const locationQuery = {\n    ...(query || {}),\n    transaction,\n  };\n  if (!defined(locationQuery.transaction)) {\n    delete locationQuery.transaction;\n  }\n\n  const target = {\n    pathname: `/organizations/${orgSlug}/performance/${eventSlug}/`,\n    query: locationQuery,\n    hash: defined(spanId) ? spanTargetHash(spanId) : undefined,\n  };\n  if (!defined(target.hash)) {\n    delete target.hash;\n  }\n\n  return target;\n}\n"],"names":["setSpansOnTransaction","spanCount","transaction","getPerformanceTransaction","spanGroup","find","g","setTag","normalizeTimestamps","spanBounds","startTimestamp","endTimestamp","TimestampStatus","boundsGenerator","bounds","viewStart","viewEnd","traceStartTimestamp","traceEndTimestamp","traceDuration","viewStartTimestamp","viewDuration","type","isSpanVisibleInView","timestampStatus","Stable","Equal","Reversed","parseSpanTimestamps","start","end","width","generateRootSpan","trace","trace_id","traceID","span_id","rootSpanID","parent_span_id","parentSpanID","start_timestamp","timestamp","op","description","data","status","rootSpanStatus","hash","exclusive_time","exclusiveTime","getTraceDateTimeRange","input","moment","subtract","utc","format","add","isGapSpan","span","isOrphanSpan","isOrphan","getSpanID","defaultSpanID","getSpanOperation","getTraceContext","event","contexts","parseTrace","spanEntry","entries","entry","EntryType","spans","traceContext","rootSpanOpName","length","childSpans","potentialParents","Set","map","init","reduced","reduce","acc","inputSpan","parentSpanId","getSpanParentSpanID","hasParent","has","maybeSpanID","isString","assert","spanChildren","push","set","hasEndTimestamp","isNumber","Object","values","forEach","sort","sortSpans","firstSpan","secondSpan","isOrphanTreeDepth","treeDepth","unwrapTreeDepth","depth","isEventFromBrowserJavaScriptSDK","sdkName","sdk","name","includes","toLowerCase","durationlessBrowserOps","hasFailedThreshold","marks","names","keys","WEB_VITAL_DETAILS","filter","vital","slug","some","record","value","poorThreshold","getMeasurements","generateBounds","measurements","Map","allowedVitals","WebVital","associatedMeasurement","undefined","mergedMeasurements","measurement","roundedPos","Math","round","otherPos","abs","MERGE_LABELS_THRESHOLD_PERCENT","verticalMark","get","failedThreshold","getMeasurementBounds","warning","left","scrollToSpan","spanId","scrollToHash","location","organization","e","preventDefault","spanTargetHash","browserHistory","trackAdvancedAnalyticsEvent","getSiblingGroupKey","occurrence","getSpanGroupTimestamps","spanGroupItem","newStartTimestamp","newEndTimestamp","getSpanGroupBounds","SpansInViewMap","constructor","isRootSpanInView","this","spanDepthsInView","treeDepthSum","addSpan","removeSpan","delete","getScrollVal","TOGGLE_BORDER_BOX","TOGGLE_BUTTON_MAX_WIDTH","getCumulativeAlertLevelFromErrors","errors","highestErrorLevel","maxBy","error","ERROR_LEVEL_WEIGHTS","level","ERROR_LEVEL_TO_ALERT_TYPE","fatal","default","sample","info","unknown","getFormattedTimeRangeWithLeadingAndTrailingZero","startStrings","String","split","endStrings","newTimestamps","startString","index","padStart","padEnd","join","groupShouldBeHidden","group","focusedSpanIDs","spanModel","getTransactionDetailsUrl","orgSlug","eventSlug","query","locationQuery","defined","target","pathname"],"sourceRoot":""}