# noqa: D100
import logging
from struct import error as structerror
from typing import List, Tuple, Union

import progressbar  # type: ignore[import]
from intelhex import IntelHex  # type: ignore[import]
from serial import Serial  # type: ignore[import]

from mcbootflash.error import (
    BadAddress,
    BadLength,
    ChecksumError,
    ConnectionFailure,
    FlashEraseFail,
    NoData,
    UnexpectedResponse,
    UnsupportedCommand,
    VerifyFail,
)
from mcbootflash.protocol import (
    BootCommand,
    BootResponse,
    ChecksumPacket,
    CommandPacket,
    MemoryRangePacket,
    ResponsePacket,
    VersionResponsePacket,
)

logger = logging.getLogger(__name__)

__all__ = ["BootloaderConnection"]

_BOOTLOADER_EXCEPTIONS = {
    BootResponse.UNSUPPORTED_COMMAND: UnsupportedCommand,
    BootResponse.BAD_ADDRESS: BadAddress,
    BootResponse.BAD_LENGTH: BadLength,
    BootResponse.VERIFY_FAIL: VerifyFail,
}


class BootloaderConnection(
    Serial,  # type: ignore[misc]
):  # pylint: disable=too-many-ancestors
    """Communication interface to device running MCC 16-bit bootloader.

    BootloaderConnection subclasses serial.Serial from pyserial. When creating a new
    BootloaderConnection instance, you will typically need to specify at least the
    'port' and 'baudrate' arguments from the parent class. See pyserial's documentation
    for detailed information about the serial.Serial class.
    """

    # Is this key always the same? Perhaps generated by MCC during code generation?
    # If this key is incorrect, flash write operations will fail silently.
    _FLASH_UNLOCK_KEY = 0x00AA0055

    def __init__(self, **kwargs: str):
        super().__init__(**kwargs)
        self._bar: Union[None, progressbar.Bar] = None

    def flash(self, hexfile: str, quiet: bool = False) -> None:
        """Flash application firmware.

        Parameters
        ----------
        hexfile : str
            Path to a HEX-file containing application firmware.
        quiet : bool (optional)
            If true, don't print a progressbar while flashing. False by default.

        Raises
        ------
        ConnectionFailure
            If bootloader does not respond.
        NoData
            If HEX file contains no flashable data.
        UnexpectedResponse
            If `command`-field of reply does not match most recent command.
        FlashEraseFail
            If an existing program could not be erased.
        ChecksumError
            If local and remote checksums do not match.
        """
        path = hexfile
        hexfile = IntelHex(path)
        max_packet_length, erase_size, write_size, program_memory = self._connect()
        segments = self._get_segments_in_range(hexfile, program_memory)

        if not segments:
            raise NoData(
                "HEX file contains no data that fits entirely within program memory"
            )

        self.erase_flash(erase_size, program_memory)
        logger.info(f"Flashing {path}")
        chunk_size = max_packet_length - CommandPacket.get_size()
        chunk_size -= chunk_size % write_size
        total_bytes = sum(len(segment) for segment in segments)
        written_bytes = 0

        for segment in segments:
            chunks = self._chunk(segment, chunk_size)
            logger.debug(f"Flashing segment {segments.index(segment)}")

            for chunk in chunks:
                self._write_flash(chunk, write_size)
                written_bytes += len(chunk)
                logger.debug(
                    f"{written_bytes} bytes written of {total_bytes} "
                    f"({written_bytes / total_bytes * 100:.2f}%)"
                )
                self._checksum(chunk)

                if not quiet:
                    self._print_progress(written_bytes, total_bytes)

        self._self_verify()

    def _connect(self) -> Tuple[int, int, int, range]:
        logger.info("Connecting to bootloader...")

        try:
            _, max_packet_length, _, erase_size, write_size = self.read_version()
        except structerror as exc:
            raise ConnectionFailure("No response from bootloader") from exc

        program_memory = range(*self._get_memory_address_range())
        logger.info("Connected")
        return max_packet_length, erase_size, write_size, program_memory

    @staticmethod
    def _get_segments_in_range(
        hexfile: IntelHex, program_memory: range
    ) -> List[IntelHex]:
        segments = []

        for addr_range in hexfile.segments():
            # Since the MCU uses 16-bit instructions, each "address" in the (8-bit) hex
            # file is actually only half an address. Therefore, we need to divide by two
            # to get the actual address.
            if all(addr >> 1 in program_memory for addr in addr_range):
                logger.debug(
                    "Adding HEX segment {i}: "
                    f"{addr_range[0] >> 1:#08x}:{addr_range[1] >> 1:#08x}"
                )
                segments.append(hexfile[addr_range[0] : addr_range[1]])
            else:
                logger.debug(
                    f"HEX segment {hexfile.segments().index(addr_range)} ignored; "
                    "not in program memory range:"
                )
                logger.debug(
                    f"([{addr_range[0] >> 1:#08x}:{addr_range[1] >> 1:#08x}] vs. "
                    f"[{program_memory[0]:#08x}:"
                    f"{program_memory[-1]:#08x}])"
                )

        return segments

    @staticmethod
    def _chunk(hexfile: IntelHex, size: int) -> List[IntelHex]:
        start = hexfile.minaddr()
        stop = hexfile.maxaddr()
        return [hexfile[i : i + size] for i in range(start, stop, size)]

    def _print_progress(self, written_bytes: int, total_bytes: int) -> None:
        if self._bar is None:
            widgets = [
                progressbar.Percentage(),
                " ",
                progressbar.DataSize(),
                " ",
                progressbar.Bar(),
                " ",
                progressbar.Timer(),
            ]
            progress = progressbar.ProgressBar(widgets=widgets)
            self._bar = progress.start(max_value=total_bytes)
        elif written_bytes == total_bytes:
            self._bar.finish()
            self._bar = None
        else:
            self._bar.update(value=written_bytes)

    @staticmethod
    def _check_response(
        command_packet: CommandPacket,
        response_packet: Union[VersionResponsePacket, ResponsePacket],
    ) -> None:
        """Check that response is not an error."""
        if response_packet.command != command_packet.command:
            raise UnexpectedResponse(
                f"Sent {command_packet.command.name} command but reply was "
                f"{BootCommand(response_packet.command).name}"
            )

        if isinstance(response_packet, VersionResponsePacket):
            return

        if response_packet.success != BootResponse.SUCCESS:
            logger.debug("Command failed:")
            logger.debug(f"Command:  {bytes(command_packet)!r}")
            logger.debug(f"Response: {bytes(response_packet)!r}")
            raise _BOOTLOADER_EXCEPTIONS[response_packet.success]

    def read_version(self) -> Tuple[int, int, int, int, int]:
        """Read bootloader version and some other useful information.

        Returns
        -------
        version : int
        max_packet_length : int
            The maximum size of a single packet sent to the bootloader,
            including both the command and associated data.
        device_id : int
        erase_size : int
            Flash page size. When erasing flash memory, the number of bytes to
            be erased must align with a flash page.
        write_size : int
            Write block size. When writing to flash, the number of bytes to be
            written must align with a write block.
        """
        read_version_command = CommandPacket(command=BootCommand.READ_VERSION)
        self.write(bytes(read_version_command))
        read_version_response = VersionResponsePacket.from_serial(self)
        self._check_response(read_version_command, read_version_response)
        logger.debug("Got bootloader attributes:")
        logger.debug(f"Max packet length: {read_version_response.max_packet_length}")
        logger.debug(f"Erase size:        {read_version_response.erase_size}")
        logger.debug(f"Write size:        {read_version_response.write_size}")

        return (
            read_version_response.version,
            read_version_response.max_packet_length,
            read_version_response.device_id,
            read_version_response.erase_size,
            read_version_response.write_size,
        )

    def _get_memory_address_range(self) -> Tuple[int, int]:
        mem_range_command = CommandPacket(command=BootCommand.GET_MEMORY_ADDRESS_RANGE)
        self.write(bytes(mem_range_command))
        mem_range_response = MemoryRangePacket.from_serial(self)
        self._check_response(mem_range_command, mem_range_response)
        logger.debug(
            "Got program memory range: "
            f"{mem_range_response.program_start:#08x}:"
            f"{mem_range_response.program_end:#08x}"
        )
        return mem_range_response.program_start, mem_range_response.program_end

    def erase_flash(
        self,
        erase_size: Union[None, int] = None,
        erase_range: Union[None, range] = None,
        force: bool = False,
        verify: bool = True,
    ) -> None:
        """Erase program memory area.

        Parameters
        ----------
        erase_size: int, optional
            Size of an erase flash page in bytes. Read from connected device if not
            specified.
        erase_range: range, optional
            Address range to erase. By default the entire program memory is erased.
        force : bool, optional
            By default, flash erase will be skipped if no program is detected in the
            program memory area. Setting `force` to True skips program detection and
            erases regardless of whether a program is present or not.
        verify : bool, optional
            The ERASE_FLASH command may fail silently if the `unlock_sequence` field of
            the command packet is incorrect. By default, this method verifies that the
            erase was successful by checking that no application is detected after the
            erase. Set `verify` to False to skip this check.
        """
        erase_size = erase_size or self.read_version()[3]

        if erase_range is None:
            start_address, end_address = self._get_memory_address_range()
        else:
            start_address, end_address = erase_range[0], erase_range[-1]

        if force:
            self._erase_flash(start_address, end_address, erase_size)
            erased = True
        else:
            erased = self._erase_unless_empty(start_address, end_address, erase_size)

        if erased and verify:
            self._verify_erase()

    def _erase_flash(
        self, start_address: int, end_address: int, erase_size: int
    ) -> None:
        erase_flash_command = CommandPacket(
            command=BootCommand.ERASE_FLASH,
            data_length=(end_address - start_address) // erase_size,
            unlock_sequence=self._FLASH_UNLOCK_KEY,
            address=start_address,
        )
        logger.debug(f"Erasing addresses {start_address:#08x}:{end_address:#08x}")
        self.write(bytes(erase_flash_command))
        erase_flash_response = ResponsePacket.from_serial(self)
        self._check_response(erase_flash_command, erase_flash_response)

    def _erase_unless_empty(
        self, start_address: int, end_address: int, erase_size: int
    ) -> bool:
        try:
            # Program memory may be empty, which should not be logged as an error.
            logger.disabled = True
            self._self_verify()
        except VerifyFail:
            logger.disabled = False
            logger.info("No application detected, skipping flash erase")
            return False
        finally:
            logger.disabled = False

        logger.info("Existing application detected, erasing...")
        self._erase_flash(start_address, end_address, erase_size)
        return True

    def _verify_erase(self) -> None:
        try:
            logger.disabled = True
            self._self_verify()
        except VerifyFail:
            logger.disabled = False
            logger.info("No application detected; flash erase successful")
            return
        finally:
            logger.disabled = False

        logger.debug("An application was detected; flash erase failed")
        logger.debug("unlock_sequence field may be incorrect")
        raise FlashEraseFail("Existing application could not be erased")

    def _write_flash(self, data: IntelHex, align: int) -> None:
        padding = bytes([data.padding] * ((align - (len(data) % align)) % align))
        write_flash_command = CommandPacket(
            command=BootCommand.WRITE_FLASH,
            data_length=len(data) + len(padding),
            unlock_sequence=self._FLASH_UNLOCK_KEY,
            address=data.minaddr() >> 1,
        )
        logger.debug(
            f"Writing ({len(data)} + {len(padding)}) bytes to {data.minaddr():#08x}"
        )
        self.write(bytes(write_flash_command) + data.tobinstr() + padding)
        write_flash_response = ResponsePacket.from_serial(self)
        self._check_response(write_flash_command, write_flash_response)

    def _self_verify(self) -> None:
        self_verify_command = CommandPacket(command=BootCommand.SELF_VERIFY)
        self.write(bytes(self_verify_command))
        self_verify_response = ResponsePacket.from_serial(self)
        self._check_response(self_verify_command, self_verify_response)
        logger.info("Self verify OK")

    def _get_checksum(self, address: int, length: int) -> int:
        calculcate_checksum_command = CommandPacket(
            command=BootCommand.CALC_CHECKSUM,
            data_length=length,
            address=address,
        )
        self.write(bytes(calculcate_checksum_command))
        calculate_checksum_response = ChecksumPacket.from_serial(self)
        self._check_response(calculcate_checksum_command, calculate_checksum_response)
        return calculate_checksum_response.checksum

    @staticmethod
    def _calculate_checksum(data: IntelHex) -> int:
        checksum = 0
        start = data.minaddr()
        stop = start + len(data)
        step = 4

        for i in range(start, stop, step):
            databytes = data[i : i + step].tobinstr()
            checksum += int.from_bytes(databytes, byteorder="little") & 0xFFFF
            checksum += (int.from_bytes(databytes, byteorder="little") >> 16) & 0xFF

        return checksum & 0xFFFF

    def _checksum(self, hexfile: IntelHex) -> None:
        """Compare checksums calculated locally and onboard device.

        Parameters
        ----------
        address : int
            Address from which to start checksum.
        length : int
            Number of bytes to checksum.
        """
        checksum1 = self._calculate_checksum(hexfile)
        checksum2 = self._get_checksum(hexfile.minaddr() >> 1, len(hexfile))

        if checksum1 != checksum2:
            logger.debug(f"Checksum mismatch: {checksum1} != {checksum2}")
            logger.debug("unlock_sequence field may be incorrect")
            raise ChecksumError

        logger.debug(f"Checksum OK: {checksum1}")

    def reset(self) -> None:
        """Reset device."""
        reset_command = CommandPacket(command=BootCommand.RESET_DEVICE)
        self.write(bytes(reset_command))
        reset_response = ResponsePacket.from_serial(self)
        self._check_response(reset_command, reset_response)
        logger.info("Device reset")

    def _read_flash(self) -> None:
        raise NotImplementedError
