Metadata-Version: 2.1
Name: autobot-ml
Version: 0.0.7
Summary: An automated code refactoring tool powered by GPT-3.
Home-page: https://github.com/charliermarsh/autobot
License: MIT
Author: Charlie Marsh
Author-email: charlie.r.marsh@gmail.com
Requires-Python: >=3.8,<3.11
Classifier: Development Status :: 3 - Alpha
Classifier: Environment :: Console
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Classifier: Programming Language :: Python
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3 :: Only
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Classifier: Topic :: Software Development :: Quality Assurance
Requires-Dist: colorama (>=0.4.5,<0.5.0)
Requires-Dist: openai (>=0.23.0,<0.24.0)
Requires-Dist: python-dotenv (>=0.21.0,<0.22.0)
Requires-Dist: rich (>=12.5.1,<13.0.0)
Project-URL: Repository, https://github.com/charliermarsh/autobot
Description-Content-Type: text/markdown

# autobot

An automated code refactoring tool powered by GPT-3. Like GitHub Copilot, for your existing
codebase.

Autobot takes an example change as input and generates patches for you to review by scanning your
codebase for similar code blocks and "applying" that change to the existing source code.

## Getting started

Autobot is available as [`autobot-ml`](https://pypi.org/project/autobot-ml/) on PyPI:

```shell
pip install autobot-ml
```

Autobot depends on the [OpenAI API](https://openai.com/api/) and, in particular, expects your OpenAI
organization ID and API key to be exposed as the `OPENAI_ORGANIZATION` and `OPENAI_API_KEY`
environment variables, respectively.

Autobot can also read from a `.env` file:

```
OPENAI_ORGANIZATION=${YOUR_OPENAI_ORGANIZATION}
OPENAI_API_KEY=${YOUR_OPENAI_API_KEY}
```

## Example usage

_TL;DR: Autobot is a command-line tool. To generate patches, use `autobot run`; to review the
generated patches, use `autobot review`._

Autobot is designed around a two-step workflow.

In the first step (`autobot run {schematic} {files_to_analyze}`), we point Autobot to (1) the
"schematic" that defines our desired change and (2) the files to which the change should be
applied.

In the second step (`autobot review`), we review the patches that Autobot generated and, for each
suggested change, either apply it to the codebase or reject the patch entirely.

Autobot ships with several schematics that you can use out-of-the-box:

- `assert_equals`
- `convert_to_dataclass`
- `numpy_builtin_aliases`
- `print_statement`
- `sorted_attributes`
- `standard_library_generics`
- `unnecessary_f_strings`
- `use_generator`
- `useless_object_inheritance`

For example: to remove any usages of NumPy's deprecated `np.int` and associated aliases, we'd first
run `autobot run numpy_builtin_aliases ./path/to/main.py`, followed by `autobot review`.

The `schematic` argument to `autobot run` can either reference a directory within `schematics` (like
`numpy_builtin_aliases`, above) or a path to a user-defined schematic directory on-disk.

### Implementing a novel refactor

Every refactor facilitated by Autobot requires a "schematic". Autobot ships with a few schematics
in the `schematics` directory, but it's intended to be used with user-provided schematics.

A schematic is a directory containing three files:

1. `before.py`: A code snippet demonstrating the "before" state of the refactor.
2. `after.py`: A code snippet demonstrating the "after" state of the refactor.
3. `autobot.json`: A JSON object containing a plaintext description of the
   before (`before_description`) and after (`after_description`) states, along with
   the `transform_type` ("Function" or "Class").

For example: in Python 3, `class Foo(object)` is equivalent to `class Foo`. To automatically remove
those useless object inheritances from our codebase, we'd create a `useless_object_inheritance`
directory, and add the above files.

```python
# before.py
class Foo(Bar, object):
    def __init__(self, x: int) -> None:
        self.x = x
```

```python
# after.py
class Foo(Bar):
    def __init__(self, x: int) -> None:
        self.x = x
```

```json
// autobot.json
{
    "before_description": "with object inheritance",
    "after_description": "without object inheritance",
    "transform_type": "Class"
}
```

We'd then run `autobot run ./useless_object_inheritance /path/to/file/or/directory` to generate
patches, followed by `autobot review` to apply or reject the suggested changes.

## Limitations

1. Running Autobot consumes OpenAI credits and thus could cost you money. Be careful!
2. To speed up execution, Autobot calls out to the OpenAI API in parallel. If you haven't upgraded
   to a paid account, you may hit rate-limit errors. You can pass `--nthreads 1` to `autobot run`
   to disable multi-threading. Running Autobot over large codebases is not recommended (yet).
3. Depending on the transform type, Autobot will attempt to generate a patch for every function or
   every
   class. Any function or class that's "too long" for GPT-3's maximum prompt size will be skipped.
4. Autobot isn't smart enough to handle nested functions (or nested classes), so nested functions
   will likely be processed and appear twice.
5. Autobot only supports Python code for now. (Autobot relies on parsing the AST to extract relevant
   code snippets, so additional languages require extending AST support.)

## License

MIT

